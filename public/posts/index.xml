<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Memory notes</title>
    <link>https://ksysoev.github.io/posts/</link>
    <description>Recent content in Posts on Memory notes</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>en</language>
    <copyright>Â©2024 Kirill Sysoev</copyright>
    <lastBuildDate>Sun, 23 Jun 2024 11:14:49 +0800</lastBuildDate>
    <atom:link href="https://ksysoev.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go Custom Profilers</title>
      <link>https://ksysoev.github.io/posts/go-custom-profilers/</link>
      <pubDate>Sun, 23 Jun 2024 11:14:49 +0800</pubDate>
      <guid>https://ksysoev.github.io/posts/go-custom-profilers/</guid>
      <description>In the ever-evolving landscape of software development, the need for precise and tailored performance analysis has never been more critical. Go, with its robust performance and concurrency model, offers developers a powerful platform for building efficient applications. However, even with Go&amp;rsquo;s built-in profiling tools, there are scenarios where a more customized approach is necessary to truly understand and optimize your application&amp;rsquo;s performance. This article dives into the world of custom profilers in Go, showcasing how to extend beyond the standard profiling tools to capture and analyze the specific metrics that matter most to your application.</description>
    </item>
    <item>
      <title>CPU Profiling in Go with pprof</title>
      <link>https://ksysoev.github.io/posts/go-cpu-profile/</link>
      <pubDate>Sun, 16 Jun 2024 18:48:26 +0800</pubDate>
      <guid>https://ksysoev.github.io/posts/go-cpu-profile/</guid>
      <description>Performance is a critical aspect of any application. Understanding how your program utilizes CPU resources can provide valuable insights into potential bottlenecks and areas for optimization. One of the most effective ways to visualize CPU usage is through a flame chart, a graphical representation of your program&amp;rsquo;s call stack over time.
In the realm of Go, a statically typed, compiled language renowned for its simplicity and efficiency, we have robust built-in tools for performance analysis.</description>
    </item>
    <item>
      <title>Understanding and Utilizing Error Wrapping in Go</title>
      <link>https://ksysoev.github.io/posts/go-error-wrapping/</link>
      <pubDate>Mon, 10 Jun 2024 20:31:28 +0800</pubDate>
      <guid>https://ksysoev.github.io/posts/go-error-wrapping/</guid>
      <description>In Go, error handling is a crucial aspect of creating robust and reliable software. One common scenario is when you need to pass an error up the call stack, but also want to add additional context. This is where error wrapping comes into play.
Wrapping Errors The fmt package in Go provides a function called Errorf that allows you to create formatted error messages. It also supports a special placeholder %w that can be used to wrap errors with additional context.</description>
    </item>
  </channel>
</rss>
